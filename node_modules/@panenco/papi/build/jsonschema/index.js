"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.targetConstructorToSchema = exports.validationMetadataArrayToSchemas = exports.validationMetadatasToSchemas = void 0;
// tslint:disable:no-submodule-imports ban-types
const cv = __importStar(require("class-validator"));
const lodash_groupby_1 = __importDefault(require("lodash.groupby"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const JSONSchema_decorator_js_1 = require("../decorators/JSONSchema.decorator.js");
const defaultConverters_1 = require("./defaultConverters");
const options_1 = require("./options");
/**
 * Convert class-validator metadata into JSON Schema definitions.
 */
function validationMetadatasToSchemas(userOptions) {
    const options = {
        ...options_1.defaultOptions,
        ...userOptions,
    };
    const metadatas = getMetadatasFromStorage(options.classValidatorMetadataStorage);
    const flatMetadatas = [].concat(...metadatas.values());
    return validationMetadataArrayToSchemas(flatMetadatas, userOptions);
}
exports.validationMetadatasToSchemas = validationMetadatasToSchemas;
/**
 * Convert an array of class-validator metadata into JSON Schema definitions.
 */
function validationMetadataArrayToSchemas(metadatas, userOptions) {
    const options = {
        ...options_1.defaultOptions,
        ...userOptions,
    };
    const schemas = {};
    Object.entries((0, lodash_groupby_1.default)(metadatas, ({ target }) => { var _a; return (_a = target[options.schemaNameField]) !== null && _a !== void 0 ? _a : target.name; })).forEach(([key, ownMetas]) => {
        const target = ownMetas[0].target;
        const metas = ownMetas
            .concat(getInheritedMetadatas(target, metadatas))
            .filter(propMeta => !(isExcluded(propMeta, options) || isExcluded({ ...propMeta, target }, options)));
        const properties = {};
        Object.entries((0, lodash_groupby_1.default)(metas, 'propertyName')).forEach(([propName, propMetas]) => {
            const schema = applyConverters(propMetas, options);
            properties[propName] = applyDecorators(schema, target, options, propName);
        });
        const definitionSchema = {
            properties,
            type: 'object',
        };
        const required = getRequiredPropNames(target, metas, options);
        if (required.length > 0) {
            definitionSchema.required = required;
        }
        schemas[key] = applyDecorators(definitionSchema, target, options, target.name);
    });
    return schemas;
}
exports.validationMetadataArrayToSchemas = validationMetadataArrayToSchemas;
/**
 * Generate JSON Schema definitions from the target object constructor.
 */
function targetConstructorToSchema(targetConstructor, userOptions) {
    const options = {
        ...options_1.defaultOptions,
        ...userOptions,
    };
    const storage = options.classValidatorMetadataStorage;
    let metadatas = storage.getTargetValidationMetadatas(targetConstructor, '', true, false);
    metadatas = populateMetadatasWithConstraints(storage, metadatas);
    const schemas = validationMetadataArrayToSchemas(metadatas, userOptions);
    return Object.values(schemas).length ? Object.values(schemas)[0] : {};
}
exports.targetConstructorToSchema = targetConstructorToSchema;
/**
 * Return `storage.validationMetadatas` populated with `constraintMetadatas`.
 */
function getMetadatasFromStorage(storage) {
    const metadatas = storage.validationMetadatas;
    const map = new Map();
    metadatas.forEach((value, target) => {
        map.set(target, populateMetadatasWithConstraints(storage, value));
    });
    return map;
}
function populateMetadatasWithConstraints(storage, metadatas) {
    const constraints = storage.constraintMetadatas;
    return metadatas.map(meta => {
        if (meta.constraintCls) {
            const constraint = constraints.get(meta.constraintCls);
            if (constraint && constraint.length > 0) {
                return { ...meta, type: constraint[0].name };
            }
        }
        return meta;
    });
}
/**
 * Return target class' inherited validation metadatas, with original metadatas
 * given precedence over inherited ones in case of duplicates.
 *
 * Adapted from `class-validator` source.
 *
 * @param target Target child class.
 * @param metadatas All class-validator metadata objects.
 */
function getInheritedMetadatas(target, metadatas) {
    return metadatas.filter(d => d.target instanceof Function &&
        target.prototype instanceof d.target &&
        !metadatas.find(m => m.propertyName === d.propertyName && m.target === target && m.type === d.type));
}
/**
 * Convert a property's class-validator metadata into a JSON Schema property.
 */
function applyConverters(propertyMetadatas, options) {
    const converters = { ...defaultConverters_1.defaultConverters, ...options.additionalConverters };
    const convert = (meta) => {
        var _a;
        const typeMeta = (_a = options.classTransformerMetadataStorage) === null || _a === void 0 ? void 0 : _a.findTypeMetadata(meta.target, meta.propertyName);
        const isMap = typeMeta && typeMeta.reflectedType && new typeMeta.reflectedType() instanceof Map;
        const converter = converters[meta.type] || converters[cv.ValidationTypes.CUSTOM_VALIDATION];
        const items = typeof converter === 'function' ? converter(meta, options) : converter;
        if (meta.each && isMap) {
            return {
                additionalProperties: {
                    ...items,
                },
                type: 'object',
            };
        }
        return meta.each ? { items, type: 'array' } : items;
    };
    return (0, lodash_merge_1.default)({}, ...propertyMetadatas.map(convert));
}
/** Check whether property is excluded with class-transformer `@Exclude` decorator. */
function isExcluded(propertyMetadata, options) {
    var _a;
    return !!((_a = options.classTransformerMetadataStorage) === null || _a === void 0 ? void 0 : _a.findExcludeMetadata(propertyMetadata.target, propertyMetadata.propertyName));
}
/**
 * Given a JSON Schema object, supplement it with additional schema properties
 * defined by target object's @JSONSchema decorator.
 */
function applyDecorators(schema, target, options, propertyName) {
    const additionalSchema = (0, JSONSchema_decorator_js_1.getMetadataSchema)(target.prototype, propertyName);
    return typeof additionalSchema === 'function'
        ? additionalSchema(schema, options)
        : (0, lodash_merge_1.default)({}, schema, additionalSchema);
}
/**
 * Get the required property names of a validated class.
 * @param target Validation target class.
 * @param metadatas Validation metadata objects of the validated class.
 * @param options Global class-validator options.
 */
function getRequiredPropNames(target, metadatas, options) {
    function isDefined(metas) {
        return metas && metas.some(({ type }) => type === cv.ValidationTypes.IS_DEFINED);
    }
    function isOptional(metas) {
        return metas && metas.some(({ type }) => [cv.ValidationTypes.CONDITIONAL_VALIDATION, cv.IS_EMPTY].includes(type));
    }
    return Object.entries((0, lodash_groupby_1.default)(metadatas, m => m.propertyName))
        .filter(([_, metas]) => {
        const own = metas.filter(m => m.target === target);
        const inherited = metas.filter(m => m.target !== target);
        return options.skipMissingProperties
            ? isDefined(own) || (!isOptional(own) && isDefined(inherited))
            : !(isOptional(own) || isOptional(inherited));
    })
        .map(([name]) => name);
}
//# sourceMappingURL=index.js.map