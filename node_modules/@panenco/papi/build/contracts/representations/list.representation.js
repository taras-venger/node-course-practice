"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createListRepresentation = exports.ListRepresentation = void 0;
const class_transformer_1 = require("class-transformer");
const decorators_1 = require("../../decorators");
/**
 * Output DTO for paginated lists
 *
 * @category Contract
 */
class ListRepresentation {
    constructor(count, items) {
        this.count = count;
        this.items = items;
    }
}
exports.ListRepresentation = ListRepresentation;
/**
 * Output DTO for paginated lists. In order to generate the correct metadata for the validation and API documentation for the list schema we need to generate the class with the class type of the child DTO of the list.
 * This function can be used in combination with the representer. But a shorthand [[listRepresenter]] als o exists.
 * @param type The class type of a single list item
 * @returns The class type of a list representation with the necessary metadata for the items array. Similar to [[ListRepresentation<TChild>]] but with metadata.
 *
 * @category Contract
 */
const createListRepresentation = (type) => {
    const name = `${type.name}ListRepresentation`;
    let ListRepresentationFactory = class ListRepresentationFactory {
    };
    __decorate([
        (0, class_transformer_1.Expose)(),
        (0, decorators_1.Numeric)(),
        __metadata("design:type", Number)
    ], ListRepresentationFactory.prototype, "count", void 0);
    __decorate([
        (0, class_transformer_1.Expose)(),
        (0, decorators_1.Nested)(type, true),
        __metadata("design:type", Array)
    ], ListRepresentationFactory.prototype, "items", void 0);
    ListRepresentationFactory = __decorate([
        (0, class_transformer_1.Exclude)()
    ], ListRepresentationFactory);
    Object.defineProperty(ListRepresentationFactory, 'name', { value: name });
    return ListRepresentationFactory;
};
exports.createListRepresentation = createListRepresentation;
//# sourceMappingURL=list.representation.js.map